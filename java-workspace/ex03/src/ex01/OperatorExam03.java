package ex01;

public class OperatorExam03 {
	public static void main(String[] args) {
		// >>=, <<=, >>>=,
		System.out.println(10 >> 2);
		// 1010 = > 2칸을 오른쪽으로 이동 = > 1010 10|10
		// 2
		System.out.println(10 << 2);
		// 1010 => 2칸을 왼쪽으로 이동 =>1010 1010 101000|
		//=>40
		System.out.println(10 >>> 2);
		//System.out.println(10 <<< 2); 는 존재하지 않는다
		System.out.println(-1 >> 2); // -수에서는 -수만 +수에서는 +수만 처리가능
		System.out.println(-1 >>> 2);// +- 관계없이 처리 가능
		
		int var1 = 10;
		var1 <<= 2;
		System.out.println(var1);
		var1 >>= 2;
		System.out.println(var1);
		var1 >>>= 2;
		System.out.println(var1);
		// 0000 0000 0000 0000 0000 0000 0000 0001 : 1
		// 0011 1111 1111 1111 1111 1111 1111 1111 : -1
		//1073741823
		
		//맨앞의 비트가 0이면 ㅇ양수 맨앞의 비트가 1이면 음수
		// 0000 0000
		// 0111 1111 = 127
		// 1000 0000 = -127 = 1의 보수
		// 1의 보수의 단점은 양수 0과 음수 0 두개가 있다.
		// 1의보수
		/* - 양수의 비트 중 1을 0 으로 0을 1로 바꾸거나 음수의 비트 중 
		 * 1을 0으로 0을 1로 바꾸면 각각의 양수와 음수가된다.
		 */
		// 0000 0000 ==> 0
		// 1111 1111 => -1 => 2의 보수
		
	// 56 을 1의 보수와 2의 보수의 음수로 변경해보세요.
		/* 0 011 1000 56
		 * 1 100 0111 1의 보수 -56 
		 * 1 100 1000 2의 보수 -56 
		 * 39를 1의 보수와 2의 보수의 음수로 변경해보세요.
		 * 0 010 0111 39
		 * 1 101 1000 1의 보수 -39 
		 * 1 101 1001 2의 보수 -39 
		 * 1을 1의보수와 2의 보수의 음수로 변경해보세요.
		 *0 000 0001 1
		 *1 111 1110 1의 보수 -1 
		 *1 111 1111 2의 보수 -1 
		 */
	}
}
